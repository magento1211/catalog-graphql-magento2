<?php
/**
 * ScandiPWA - Progressive Web App for Magento
 *
 * Copyright Â© Scandiweb, Inc. All rights reserved.
 * See LICENSE for license details.
 *
 * @license OSL-3.0 (Open Software License ("OSL") v. 3.0)
 * @package scandipwa/catalog-graphql
 * @link    https://github.com/scandipwa/catalog-graphql
 */
declare(strict_types=1);

namespace ScandiPWA\CatalogGraphQl\Plugin\SearchAdapter\Aggregation;

use ScandiPWA\CatalogGraphQl\Model\Layer\Filter\Price;
use Magento\Framework\Search\RequestInterface;
use Magento\Framework\Search\Request\QueryInterface;
use Magento\Elasticsearch\SearchAdapter\Aggregation\Builder;

class BuilderPlugin {

    /**
     * Fixes issue with 'Equalize product counts' layered navigation option.
     * By default, magento removes price bucket completely, if only 1 range was generated by algorithm.
     * See details: https://github.com/scandipwa/catalog-graphql/pull/129
     *
     * @param Builder $subject
     * @param $result
     * @param RequestInterface $request
     * @return mixed
     */
    public function afterBuild(Builder $subject, $result, RequestInterface $request) {
        // Run only if price bucket was requested for layered navigation and 'Equalize product counts' is set in admin
        $requestPriceBucket = $this->getPriceAggregationRequestBucket($request);

        if(!is_null($requestPriceBucket) && $requestPriceBucket->getMethod() == 'improved'){
            // Fix price range only if just 1 price navigation option was returned
            $resultPriceBucket = $result[Price::PRICE_BUCKET] ?? null;

            if($resultPriceBucket && count($resultPriceBucket) == 1){
                // Don't fix price range if user didn't apply filter by price
                $priceFilter = $request->getQuery()->getMust()['price'] ?? null;

                if($priceFilter){
                    $from = $priceFilter->getReference()->getFrom();
                    $to = $priceFilter->getReference()->getTo();

                    // If upper price limit wasn't passed, it means that user selected last available interval, so use '*'
                    // Otherwise, add 0.01 to compensate subtraction, which will be performed later
                    $to = is_null($to) ? '*' : $to + 0.01;

                    // Reuse count of items in the range from original response
                    $count = array_values($resultPriceBucket)[0]['count'];

                    $result[Price::PRICE_BUCKET] = [
                        $from . '_' . $to => [
                            'from' => $from,
                            'to' => $to,
                            'count' => $count,
                            'value' => $from . '_' . $to
                        ]
                    ];
                }
            }
        }

        return $result;
    }

    protected function getPriceAggregationRequestBucket($request){
        foreach ($request->getAggregation() as $bucket){
            if($bucket->getName() == Price::PRICE_BUCKET){
                return $bucket;
            }
        }

        return null;
    }
}
